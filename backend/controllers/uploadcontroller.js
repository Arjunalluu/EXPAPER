import mongoose from "mongoose";
import { Readable } from "stream";
import QuestionPaper from "../models/uploadmodel.js"; // adjust the path if needed

// Controller to upload a question paper PDF and save its metadata
export const uploadQuestionPaper = async (req, res) => {
  try {
    // Get the native MongoDB database object from Mongoose connection
    const db = mongoose.connection.db;
    // Create a GridFSBucket instance with a specific bucket name (e.g., "questionPapers")
    const bucket = new mongoose.mongo.GridFSBucket(db, { bucketName: "questionPapers" });

    // Extract metadata from the request body
    const { University, year, semester, department, subject } = req.body;

    // Validate that a file has been uploaded
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    // Get the original file name and MIME type from the uploaded file (provided by multer)
    const fileName = req.file.originalname;
    const fileMimeType = req.file.mimetype;

    // Create a Readable stream from the file buffer (Multer with memory storage provides the file as a buffer)
    const readableFileStream = new Readable();
    readableFileStream.push(req.file.buffer);
    readableFileStream.push(null);

    // Create an upload stream to GridFS with the file name and content type
    const uploadStream = bucket.openUploadStream(fileName, {
      contentType: fileMimeType,
    });

    // Pipe the file into GridFS
    readableFileStream
      .pipe(uploadStream)
      .on("error", (error) => {
        console.error("Error uploading file to GridFS:", error);
        return res.status(500).json({ error: "Error uploading file" });
      })
      .on("finish", async () => {
        // Once the file is successfully stored in GridFS,
        // create a new QuestionPaper document with a reference to the file (uploadStream.id)
        const newQuestionPaper = new QuestionPaper({
          University,
          year,
          semester,
          department,
          subject,
          fileId: uploadStream.id,  // this is the _id generated by GridFS
          fileName,
          contentType: fileMimeType,
        });

        // Save the metadata in MongoDB
        await newQuestionPaper.save();
        return res.status(201).json({
          message: "File uploaded successfully",
          data: newQuestionPaper,
        });
      });
  } catch (error) {
    console.error("Upload controller error:", error);
    return res.status(500).json({ error: "Server error" });
  }
};


export const downloadQuestionPaper = async (req, res) => {
  try {
    // Extract search parameters from the request query
    const { university, year, semester, department, subject } = req.query;

    // Validate that all required fields are provided
    if (!university || !year || !semester || !department || !subject) {
      return res.status(400).json({ message: "Missing required search parameters" });
    }

    // Find the question paper using the provided fields
    const paper = await QuestionPaper.findOne({
      University: university,
      year: year,
      semester: semester,
      department: department,
      subject: subject,
    });

    if (!paper) {
      return res.status(404).json({ message: "Question paper not found" });
    }

    // Get the native MongoDB database and create a GridFSBucket instance
    const db = mongoose.connection.db;
    const bucket = new mongoose.mongo.GridFSBucket(db, { bucketName: "questionPapers" });

    // Set headers to indicate a file attachment and the correct content type
    res.set("Content-Type", paper.contentType);
    res.set("Content-Disposition", `attachment; filename="${paper.fileName}"`);

    // Open a download stream using the stored fileId from GridFS and pipe it to the response
    bucket.openDownloadStream(paper.fileId)
      .on("error", (error) => {
        console.error("Error downloading file from GridFS:", error);
        return res.status(500).json({ error: "Error downloading file" });
      })
      .pipe(res);
  } catch (error) {
    console.error("Download controller error:", error);
    return res.status(500).json({ error: "Server error" });
  }
};
